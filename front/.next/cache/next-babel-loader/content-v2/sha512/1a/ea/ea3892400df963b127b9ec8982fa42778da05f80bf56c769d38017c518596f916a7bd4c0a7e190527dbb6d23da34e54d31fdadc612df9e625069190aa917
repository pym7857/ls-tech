{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\YOUNG\\\\Documents\\\\GitHub\\\\ls-tech\\\\front\\\\components\\\\QuillEditor.js\";\nimport { useState, useEffect, useRef } from 'react';\nexport default function QuillEditor({\n  body,\n  handleQuillChange,\n  mountBody\n}) {\n  const quillElement = useRef();\n  const quillInstance = useRef();\n  const {\n    0: isError,\n    1: setIsError\n  } = useState(false);\n  const {\n    0: isLoaded,\n    1: setIsLoaded\n  } = useState(false);\n  useEffect(() => {\n    if (isLoaded) {\n      /* isLoaded가 true인 상태에서 rerenderBody를 통해 body 적용시 Quill 초기화 없이\r\n         innerHTML만 body로 바꿉니다. 이 조건이 없을 시 툴바가 중복되어 여러 개 나타나게\r\n         됩니다. */\n      const quill = quillInstance.current;\n      quill.root.innerHTML = body;\n      return;\n    }\n\n    if (quillElement.current && window.Quill) {\n      /* isLoaded가 false일 때는 Quill을 초기화합니다. */\n\n      /* Quill 옵션을 원하는 대로 수정하세요. */\n      const toolbarOptions = {\n        container: [[{\n          'size': ['small', false, 'large', 'huge']\n        }], // custom dropdown\n        [{\n          'header': [1, 2, 3, 4, 5, 6, false]\n        }], [{\n          'align': []\n        }], ['bold', 'italic', 'underline', 'strike'], // toggled buttons\n        [{\n          'color': []\n        }, {\n          'background': []\n        }], // dropdown with defaults from theme\n        [{\n          'header': 1\n        }, {\n          'header': 2\n        }], // custom button values\n        [{\n          'list': 'ordered'\n        }, {\n          'list': 'bullet'\n        }], [{\n          'script': 'sub'\n        }, {\n          'script': 'super'\n        }], // superscript/subscript\n        [{\n          'indent': '-1'\n        }, {\n          'indent': '+1'\n        }], // outdent/indent\n        [{\n          'direction': 'rtl'\n        }], // text direction\n        ['clean'], // remove formatting button\n        ['blockquote', 'link', 'code-block', 'formula', 'image', 'video'] // media\n        ]\n      };\n      quillInstance.current = new window.Quill(quillElement.current, {\n        modules: {\n          history: {\n            delay: 2000,\n            maxStack: 500,\n            userOnly: true\n          },\n          syntax: true,\n          toolbar: toolbarOptions\n        },\n        placeholder: \"본문 입력\",\n        theme: 'snow'\n      });\n      const quill = quillInstance.current;\n      quill.root.setAttribute(\"spellcheck\", \"false\"); // 초기 body state 적용\n\n      quill.root.innerHTML = body;\n      /* quill에서 text-change 이벤트 발생시에 setBody(innerHTML)을 통해 body를 업데이트합니다.\r\n         body가 업데이트되어도 useEffect 발생 조건 인자([isError, mountBody])에 body가 없으므로\r\n         QuillEditor 컴포넌트는 다시 렌더링되지 않습니다. 이는 입력 중 커서가 맨 앞으로 이동하는\r\n         문제를 방지합니다. 대신 외부에서 body가 수정되어도 rerenderBody가 호출되지 않으면 변경된\r\n         body가 적용되지 않습니다. */\n\n      quill.on(\"text-change\", () => {\n        handleQuillChange(quill.root.innerHTML);\n      });\n      setIsLoaded(true);\n    } else {\n      /* quill.min.js가 로드되어 있지 않아 window.Quill이 undefined이면 isError가\r\n         계속 변경되면서 재시도합니다. */\n      setIsError(prevIsError => !prevIsError);\n    }\n  }, [isError, mountBody]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: quillElement\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 80,\n    columnNumber: 9\n  }, this);\n}","map":{"version":3,"sources":["C:/Users/YOUNG/Documents/GitHub/ls-tech/front/components/QuillEditor.js"],"names":["useState","useEffect","useRef","QuillEditor","body","handleQuillChange","mountBody","quillElement","quillInstance","isError","setIsError","isLoaded","setIsLoaded","quill","current","root","innerHTML","window","Quill","toolbarOptions","container","modules","history","delay","maxStack","userOnly","syntax","toolbar","placeholder","theme","setAttribute","on","prevIsError"],"mappings":"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","sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\n\r\nexport default function QuillEditor({ body, handleQuillChange, mountBody }) {\r\n    const quillElement = useRef();\r\n    const quillInstance = useRef();\r\n\r\n    const [isError, setIsError] = useState(false);\r\n    const [isLoaded, setIsLoaded] = useState(false);\r\n\r\n    useEffect(() => {\r\n        if (isLoaded) {\r\n            /* isLoaded가 true인 상태에서 rerenderBody를 통해 body 적용시 Quill 초기화 없이\r\n               innerHTML만 body로 바꿉니다. 이 조건이 없을 시 툴바가 중복되어 여러 개 나타나게\r\n               됩니다. */\r\n            const quill = quillInstance.current;\r\n            quill.root.innerHTML = body;\r\n            return;\r\n        }\r\n        if (quillElement.current && window.Quill) {\r\n            /* isLoaded가 false일 때는 Quill을 초기화합니다. */\r\n\r\n            /* Quill 옵션을 원하는 대로 수정하세요. */\r\n            const toolbarOptions = {\r\n                container: [\r\n                    [{ 'size': ['small', false, 'large', 'huge'] }],    // custom dropdown\r\n                    [{ 'header': [1, 2, 3, 4, 5, 6, false] }],\r\n                    [{ 'align': [] }],\r\n                    ['bold', 'italic', 'underline', 'strike'],          // toggled buttons\r\n                    [{ 'color': [] }, { 'background': [] }],            // dropdown with defaults from theme\r\n                    [{ 'header': 1 }, { 'header': 2 }],                 // custom button values\r\n                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],\r\n                    [{ 'script': 'sub'}, { 'script': 'super' }],        // superscript/subscript\r\n                    [{ 'indent': '-1'}, { 'indent': '+1' }],            // outdent/indent\r\n                    [{ 'direction': 'rtl' }],                           // text direction\r\n                    ['clean'],                                          // remove formatting button\r\n                    ['blockquote', 'link', 'code-block', 'formula', 'image', 'video'] // media\r\n                ],\r\n            };\r\n\r\n            quillInstance.current = new window.Quill(quillElement.current, {\r\n                modules: {\r\n                    history : {\r\n                        delay: 2000,\r\n                        maxStack: 500,\r\n                        userOnly: true\r\n                    },\r\n                    syntax : true,\r\n                    toolbar : toolbarOptions\r\n                },\r\n                placeholder: \"본문 입력\",\r\n                theme : 'snow'\r\n            });\r\n\r\n            const quill = quillInstance.current;\r\n\r\n            quill.root.setAttribute(\"spellcheck\", \"false\");\r\n\r\n            // 초기 body state 적용\r\n            quill.root.innerHTML = body;\r\n\r\n            /* quill에서 text-change 이벤트 발생시에 setBody(innerHTML)을 통해 body를 업데이트합니다.\r\n               body가 업데이트되어도 useEffect 발생 조건 인자([isError, mountBody])에 body가 없으므로\r\n               QuillEditor 컴포넌트는 다시 렌더링되지 않습니다. 이는 입력 중 커서가 맨 앞으로 이동하는\r\n               문제를 방지합니다. 대신 외부에서 body가 수정되어도 rerenderBody가 호출되지 않으면 변경된\r\n               body가 적용되지 않습니다. */\r\n            quill.on(\"text-change\", () => {\r\n                handleQuillChange(quill.root.innerHTML);\r\n            });\r\n\r\n            setIsLoaded(true);\r\n        } else {\r\n            /* quill.min.js가 로드되어 있지 않아 window.Quill이 undefined이면 isError가\r\n               계속 변경되면서 재시도합니다. */\r\n            setIsError((prevIsError) => (!prevIsError));\r\n        }\r\n    }, [isError, mountBody]);\r\n\r\n\r\n    return (\r\n        <div ref={quillElement}></div>\r\n    );\r\n}"]},"metadata":{},"sourceType":"module"}